#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLE2902.h>
#include "images.h"
#include <Wire.h>
#include <HT_SSD1306Wire.h>

#define BLE_DEVICE_NAME "ESP32 BLE Sensor Server"
#define BLE_SERVICE_UUID "f6fb45ea-8102-42c4-8cfb-ac5be07f5dbe" // Generated by https://www.uuidgenerator.net/

SSD1306Wire display(0x3c, 500000, SDA_OLED, SCL_OLED, GEOMETRY_128_64, RST_OLED); // addr , freq , i2c group , resolution , rst
bool deviceConnected = false;
uint8_t LED_PIN = 35;
BLEServer *pServer = NULL;
double sensorValues[] = {0.0, 0.0, 0.0, 0.0};

class BleSensorCharacteristic : public BLECharacteristic
{
public:
  BleSensorCharacteristic(const char *descrValue, const char *uuid, const char *descrUuid) : BLECharacteristic(uuid, BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY)
  {
    BLEDescriptor *pDescr = new BLEDescriptor((uint16_t)0x2901);
    pDescr->setValue(descrValue);
    addDescriptor(pDescr);
    BLE2902 *pBLE2902 = new BLE2902();
    pBLE2902->setNotifications(true);
    addDescriptor(pBLE2902);
  }

  void SendSensorValue(double value)
  {
    setValue(value);
    notify();
    delay(500); // bluetooth stack will go into congestion, if too many packets are sent so we need to slow down a bit
    // digitalWrite(LED_PIN, HIGH);
    // delay(50);
    // digitalWrite(LED_PIN, LOW);
    Serial.println("Sent value: " + String(value) + " to client for characteristic: " + getUUID().toString().c_str());
  }
};

BleSensorCharacteristic *sensorCharacteristics[] = {
    new BleSensorCharacteristic("Water tank", "22d8381a-e6df-4ad1-a101-5e2e47c0762b", "92d839a9-0381-4b40-81be-9aad1570534d"),
    new BleSensorCharacteristic("Septic tank", "9910102a-9d4e-41ce-be93-affba54425c4", "ff9e744f-8b01-4fa2-b65f-3a52e90b223d"),
    new BleSensorCharacteristic("Temperature", "c6db06e1-7f34-48ff-9f1e-f2904ac78525", "7e55c3b1-8520-46d0-9d49-cca64861bd7d"),
    new BleSensorCharacteristic("Humidity", "df2be7ec-fb73-40b6-b2cb-3c00d37f2229", "e98ebf82-3dcc-4c50-8dcf-4327c118da26")};

class BleSensorServerCallbacks : public BLEServerCallbacks
{
  void onConnect(BLEServer *pServer)
  {
    deviceConnected = true;
    display.drawXbm(128 - BT_width, 0, BT_width, BT_height, (const unsigned char *)BT_bits);
    display.display();
    Serial.println("Device connected!");
  };

  void onDisconnect(BLEServer *pServer)
  {
    Serial.println("Device disconnected");
    deviceConnected = false;
    display.setColor(INVERSE);
    display.drawXbm(128 - BT_width, 0, BT_width, BT_height, (const unsigned char *)BT_bits);
    display.display();
    display.setColor(INVERSE);
    delay(500);                  // give the bluetooth stack the chance to get things ready
    pServer->startAdvertising(); // restart advertising
    Serial.println("Re-start advertising " + String(BLE_DEVICE_NAME) + "...");
  }
};

void setupBLE()
{
  Serial.println("Setting up BLE...");
  BLEDevice::init(BLE_DEVICE_NAME);
  // Create the BLE Server
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new BleSensorServerCallbacks());

  // Create the BLE Service
  BLEService *pService = pServer->createService(BLE_SERVICE_UUID);

  // add the characteristics to the service
  pService->addCharacteristic(sensorCharacteristics[0]);
  pService->addCharacteristic(sensorCharacteristics[1]);
  pService->addCharacteristic(sensorCharacteristics[2]);
  pService->addCharacteristic(sensorCharacteristics[3]);

  // Start the service
  pService->start();

  // Start advertising
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(BLE_SERVICE_UUID);
  pAdvertising->setScanResponse(false);
  // pAdvertising->setMinPreferred(0x06); // functions that help with iPhone connections issue
  // pAdvertising->setMinPreferred(0x12);
  BLEDevice::startAdvertising();

  Serial.println("BLE Setup Done. Started advertising " + String(BLE_DEVICE_NAME) + "...");
}

void setup()
{
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  setupDisplay();
  setupBLE();
}

void setupDisplay()
{
  display.init();
  display.clear();
  display.display();
  display.setFont(ArialMT_Plain_16);
  display.drawString(0, 0, "Initiating...");
  display.display();
}

void updateDisplay()
{
  display.clear();
  display.drawString(0, 0, "Vatten: " + String(sensorValues[0], 0) + " %");
  display.drawString(0, 16, "Septik: " + String(sensorValues[1], 0) + "%");
  display.drawString(0, 32, "Temp: " + String(sensorValues[2], 0) + "'C");
  display.drawString(0, 48, "Fukt: " + String(sensorValues[3], 0) + "%");
  if (deviceConnected)
  {
    display.drawXbm(128 - BT_width, 0, BT_width, BT_height, (const unsigned char *)BT_bits);
  }
  display.display();
}

// put your main code here, to run repeatedly:
void loop()
{
  ReadSensors();

  updateDisplay();

  if (deviceConnected)
  {
    for (int i = 0; i < 4; i++)
    {
      sensorCharacteristics[i]->SendSensorValue(sensorValues[i]);
      delay(1000);
    }
  }
  else
  {
    Serial.println("Waiting for connection...");
  }
}

void ReadSensors()
{
  delay(2000);
  sensorValues[0] = random(0, 10000) / 100.0;
  sensorValues[1] = random(0, 10000) / 100.0;
  sensorValues[2] = random(0, 10000) / 100.0;
  sensorValues[3] = random(0, 10000) / 100.0;
}
